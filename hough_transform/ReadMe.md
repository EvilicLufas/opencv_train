# 霍夫变换

霍夫变换在检测各种形状的技术中非常流行，如果要检测的形状可以用数学表达式写出，那么就可以使用霍夫变换来检测它。即使要检测的形状存在一点破坏或者扭曲也可以使用。

---
## 霍夫变换检测直线原理

一条直线可以用数学表达式$y=mx+c$或者$\rho=x \cos{\theta} + y \sin{\theta}$表示。其中$\rho$表示从原点到直线的垂直距离，$\theta$是直线的垂线与横轴$x$顺时针方向的夹角，具体如下图所示。

![](http://chenguanfuqq.gitee.io/tuquan2/img_2018_5/hough_transorm.png)

垂直线的角度为0度，水平线的角度为90度。每一条直线都可以用$(\rho,\theta)$表示。所以首先创建一个2D数组（累加器），初始化累加器，所有的值都为0。行表示为$\rho$，列表示$\theta$，这个数组的大小（细度）决定了最后结果的准确性。如果你希望角度精确到1度，那么就需要180列。对于$\rho$，最大值为图片对角线的距离，所以如果精确度要达到一个像素的级别，行数就应该与图像对角线的距离相等。

想象一下我们有一个大小为100x100的直线位于图像的中央。取直线上的第一个点，我们知道此处的$(x,y)$值。把$x$和$y$带入上边的方程组，然后遍历$\theta$的取值：$0，1,2,\cdots,180$。分别求出与其对应的$\rho$的值，这样我们就得到一系列$(\rho,\theta)$数值对，如果这个数值对在累加器中也存在相应的位置，就在这个位置上加1.所以现在累加器中的$(50,90)=1$。（一个点可能存在于多条直线中，所以对于直线上的每一个点可能是累加器中的多个值同时加1）。

现在取直线上的第二个点。重复上边的过程，更新累加器中的值。现在累加器中的$(50,90)=2$。每次处理的都是更新累加器中的值。对直线上的每一个点都执行上边的操作，每次操作完之后，累加器中的值就加1，但其他地方有时会加1，有时不会。按照这种方式下去，到最后累加器中$(50,90)$的值肯定是最大的。如果搜索累加器中的最大值，并找到其位置$(50,90)$，这说明图像中有一条直线，这条直线到原点的距离为50，它的垂线与横轴的夹角为90度。

[HOUGH TRANSFORM animation](http://homepages.inf.ed.ac.uk/amos/hough.html) 霍夫变换示例动画。

![](http://chenguanfuqq.gitee.io/tuquan2/img_2018_5/houghdemoweb.gif)

![](http://chenguanfuqq.gitee.io/tuquan2/img_2018_5/hough_rho_theta.png)

---
## 使用

### OpenCV中使用

上面介绍霍夫变换的整个过程在OpenCV中都被封装进了一个函数cv2.HoughLines，返回值就是$(\rho,\theta)$，其中$\rho$的单位是像素，$\theta$的单位是弧度，这个函数的第一个参数是一个二值化图像，所以在进行霍夫变换之前要首先进行二值化，或者进行Canny边缘检测。第二和第三个值分别表示$\rho$和$\theta$的精确度。第四个参数是阈值，只有累加器中的值高于阈值时才被认为是一条直线，也可以把它堪称能检测到的直线的最短距离（以像素点为单位）。

---
## 参考资料

[Hough Transform/霍夫变换](https://github.com/hsmyy/ComputerVision/blob/master/line/hough.md)

[霍夫曼变换(hough transform)的原理](https://mzeric.github.io/algorithm/2014/09/25/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E5%8F%98%E6%8D%A2(Hough-Transform)%E7%9A%84%E5%8E%9F%E7%90%86.html)

[Hough transform(霍夫变换)](https://www.cnblogs.com/AndyJee/p/3805594.html)
